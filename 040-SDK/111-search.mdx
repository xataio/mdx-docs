---
title: Searching records
navTitle: Searching records
keywords: ['search', 'searching']
description: Effectively search records using the Xata SDK with TypeScript or JSON
slug: sdk/search
published: true
---

Xata natively provides text-based search for your database with the following core features:

- Fuzzy matching to account for typos.
- Limit queries to specific table and column targets.
- Pre-search filters to search only a subset of your data.
- Weights and boosts allow specific columns to impact relevancy of search scores.
- Search results provide highlight markup so you can style partial matches inside returned content.

As you insert records into Xata tables, they are automatically indexed for full text-search immediately. You can run a search using the SDKs `search()` function or by using the [REST endpoint directly](/docs/api-reference/db/db_branch_name/tables/table_name/search#free-text-search-in-a-table). While the `/query` endpoint exists only at the table level, the `/search` endpoint exists both at the database branch and the table level, because it is possible to search across multiple tables.

The search index is updated asynchronously after each insert/update, meaning that the search results are eventually consistent with the results that you get from the `/query` endpoint. Another fundamental difference to the `/query` endpoint is that `/search` doesn't support following links across tables. This means that for linked records you can filter by the ID of the linked record, but not any of its other columns. If you need to filter or search by linked tables, other than by the ID, it is recommended that you denormalize the data into its own table.

## Searching across tables

The format of a search request at the branch level (across tables) has the following shape:

<TabbedCode tabs={['TypeScript', 'Python', 'Go', 'JSON']}>

```ts
const results = await xata.search.all("<search phrase>", {
  tables: [
    {
      table: "...",
      target: [...],
      filter: {...},
      boosters: [...]
    },
    { ... },
    ...
  ],
  fuzziness: 1,
  prefix: "phrase",
  highlight: {...}
});
```

```python
results = xata.data().search_branch({
  "query": "<search phrase>",
  "tables": [{
    "table": "...",
    "filter": {...},
    "target": [...],
    "boosters": [...]
  }, {
    ...
  }],
  "fuzziness": 1,
  "prefix": "phrase",
  "highlight": {...}
})
```

```go
searchClient, _ := xata.NewSearchAndFilterClient()
prefix := xata.PrefixExpressionPhrase
results, _ := searchClient.SearchBranch(context.TODO(), xata.SearchBranchRequest{
  Payload: xata.SearchBranchRequestPayload{
    Query:  *xata.String("<search phrase>"),
    Tables: []*xata.SearchBranchRequestTablesItem{
      // ..
    },
    Fuzziness: xata.Int(1),
    Prefix:    &prefix,
    Highlight: &xata.HighlightExpression{
      // ..
    },
  },
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "<search phrase>",
  "tables": [{
    "table": "...",
    "filter": {...},
    "target": [...],
    "boosters": [...]
  }, {
    ...
  }],
  "fuzziness": 1,
  "prefix": "phrase",
  "highlight": {...}
}
```

</TabbedCode>

At its simplest, a search call against all tables in your database looks like this:

<TabbedCode tabs={['TypeScript', 'Python', 'Go', 'JSON']}>

```ts
const results = await xata.search.all('new st');
```

```python
results = xata.data().search_branch({"query": "new st"})
```

```go
searchClient, _ := xata.NewSearchAndFilterClient()
results, _ := searchClient.SearchBranch(context.TODO(), xata.SearchBranchRequest{
  Payload: xata.SearchBranchRequestPayload{
    Query: "new st",
  },
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "new st"
}
```

</TabbedCode>

### Highlight matching strings in the search response

Regardless of client, the above search will return results in the below shape. Each result adds an additional `xata` object which contains metadata about the search that includes:

- The `table` where the result was found.
- The relevancy `score` of the result. See [Relevancy control](#relevancy-control) for more information.
- The `version` of the record.
- The `highlight` field, which contains the highlighted search terms.
- The `totalCount`, which is the total number of matches for a search query.

Note the `xata.highlight.address` field in the example below which marks the search term `New Set` with surrounding `<em>` tags.

```json
{
  "totalCount": 1,
  "records": [
    {
      "address": {
        "street": "123 New St",
        "zipcode": 12345
      },
      "email": "keanu@example.com",
      "full_name": "Keanu Reeves",
      "id": "rec_c8stghniqa4ckd0ao9q0",
      "xata": {
        "highlight": {
          "address": {
            "street": ["123 <em>New St</em>"]
          }
        },
        "score": 0.2876821,
        "table": "Users",
        "version": 0
      }
    }
  ]
}
```

## Restrict searches to specific tables

If you want to search only some tables in the database, provide the `tables` parameter as part of the request. It expects an array, for example:

<TabbedCode tabs={['TypeScript', 'Python', 'Go', 'JSON']}>

```ts
const results = await xata.search.all('new st', {
  tables: ['Users', 'Posts']
});

// equivalent to:
const results = await xata.search.all('new st', {
  tables: [{ table: 'Users' }, { table: 'Posts' }]
});
```

```python
results = xata.data().search_branch({
  "query": "new st",
  "tables": ["Users", "Posts"]
})

# equivalent to:
results = xata.data().search_branch({
  "query": "new st",
  "tables": [
    {"table": "Users"},
    {"table": "Posts"}
  ]
})
```

```go
searchClient, _ := xata.NewSearchAndFilterClient()
results, _ := searchClient.SearchBranch(context.TODO(), xata.SearchBranchRequest{
  Payload: xata.SearchBranchRequestPayload{
    Query:  "new st",
    Tables: []*xata.SearchBranchRequestTablesItem{
      xata.NewSearchBranchRequestTablesItemFromString("Users"),
      xata.NewSearchBranchRequestTablesItemFromString("Posts"),
    },
  },
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "new st",
  "tables": ["Users", "Posts"]
}

// equivalent to:
{
  "query": "new st",
  "tables": [
    { "table": "Users" },
    { "table": "Posts" }
  ]
}
```

</TabbedCode>

## Search a single table only

If you want to search in a single table only, it can be easier to search off the table object directly. In this case `xata.db.Users` searches against the `Users` table.

<TabbedCode tabs={['TypeScript', 'Python', 'Go', 'JSON']}>

```ts
const results = await xata.db.Users.search("<search phrase>", {
  target: [...],
  filter: {...},
  boosters: [...],
  fuzziness: 1,
  prefix: "phrase",
  highlight: {...}
});
```

```python
results = xata.data().search_table("Users", {
  "query": "<search phrase>",
  "filter": {...},
  "target": [...],
  "boosters": [...],
  "fuzziness": 1,
  "prefix": "phrase",
  "highlight": {...}
})
```

```go
searchClient, _ := xata.NewSearchAndFilterClient()
prefix := xata.PrefixExpressionPhrase
results, _ := searchClient.SearchTable(context.TODO(), xata.SearchTableRequest{
  Payload: xata.SearchTableRequestPayload{
    Query:  *xata.String("<search phrase>"),
    Filter: &xata.FilterExpression{
      // ..
    },
    Target: []*xata.TargetExpressionItem{
      // ..
    },
    Boosters: []*xata.BoosterExpression{
      // ..
    },
    Fuzziness: xata.Int(1),
    Prefix:    &prefix,
    Highlight: &xata.HighlightExpression{
      // ..
    },
  },
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/tables/{table}/search
{
  "query": "<search phrase>",
  "filter": {...},
  "target": [...],
  "boosters": [...],
  "fuzziness": 1,
  "prefix": "phrase",
  "highlight": {...}
}
```

</TabbedCode>

In other words, the table level settings from the branch-level search API (`filter`, `target`, `boosters`) are top level settings in the per-table search API.

## Fuzziness and typo tolerance

By default, Xata searches tolerates typos of one character. You can control this behavior by setting the `fuzziness` parameter, which represents the maximum [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) for the search terms. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into the other. Xata accepts 3 possible values:

- `0`: no typo tolerance
- `1`: one letter changed/added/removed (default)
- `2`: two letters changed/added/removed

For example, instead of `Keanu` you can search for `kaanu` (one letter replaced) or `kenu` (one letter missing) and still get the same result:

<TabbedCode tabs={['TypeScript', 'Python', 'Go', 'JSON']}>

```ts
const results = await xata.search.all('kaanu');
```

```python
results = xata.data().search_branch({"query": "kaanu"})
```

```go
searchClient, _ := xata.NewSearchAndFilterClient()
results, _ := searchClient.SearchBranch(context.TODO(), xata.SearchBranchRequest{
  Payload: xata.SearchBranchRequestPayload{
    Query: "kaanu",
  },
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "kaanu"
}
```

</TabbedCode>

The above matches `Keanu`. You can disable this typo tolerance by setting the `fuzziness` field to 0:

<TabbedCode tabs={['TypeScript', 'Python', 'Go', 'JSON']}>

```ts
const results = await xata.search.all('kaanu', { fuzziness: 0 });
```

```python
results = xata.data().search_branch({
  "query": "kaanu",
  "fuzziness": 0
})
```

```go
searchClient, _ := xata.NewSearchAndFilterClient()
results, _ := searchClient.SearchBranch(context.TODO(), xata.SearchBranchRequest{
  Payload: xata.SearchBranchRequestPayload{
    Query:     "kaanu",
    Fuzziness: xata.Int(0),
  },
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "kaanu",
  "fuzziness": 0
}
```

</TabbedCode>

With the `fuzziness` set to `0` the misspelling will no longer match for `Keanu`. You can also increase the `fuzziness` to accept a larger amount of typos.

<TabbedCode tabs={['TypeScript', 'Python', 'Go', 'JSON']}>

```ts
const results = await xata.search.all('kaano', { fuzziness: 2 });
```

```python
results = xata.data().search_branch({
  "query": "kaanu",
  "fuzziness": 2
})
```

```go
searchClient, _ := xata.NewSearchAndFilterClient()
results, _ := searchClient.SearchBranch(context.TODO(), xata.SearchBranchRequest{
  Payload: xata.SearchBranchRequestPayload{
    Query:     "kaanu",
    Fuzziness: xata.Int(2),
  },
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "kaano",
  "fuzziness": 2
}
```

</TabbedCode>

The above will match records containing `Keanu`.

## Filter records before search is performed

Filtering allows you to filter out records before passing them through the search algorithm. The filtering syntax is the same as for the query API, with the limitation that you cannot filter by linked columns.

The filtering is applied at the table level. For example:

<TabbedCode tabs={['TypeScript', 'Python', 'JSON']}>
```ts
const results = await xata.search.all("new st", {
tables: [
    {
      table: "Users",
      filter: {
        "address.city": "New York",
      },
    },
  ],
});
```

```python
results = xata.data().search_branch({
  "query": "kaanu",
  "tables": [
    {
      "table": "Users",
      "filter": {
        "address.city": "New York"
      }
    }
  ]
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "new st",
  "tables": [
    {
      "table": "Users",
      "filter": {
        "address.city": "New York"
      }
    }
  ]
}
```

</TabbedCode>

## Targeting specific columns

By default, Xata searches across all columns from the selected tables. You can restrict the search to specific columns by using the `target` field.

<TabbedCode tabs={['TypeScript', 'Python', 'Go', 'JSON']}>

```ts
const results = await xata.search.all('new st', {
  tables: [
    {
      table: 'Users',
      target: ['name', 'address.street']
    }
  ]
});
```

```python
results = xata.data().search_branch({
  "query": "kaanu",
  "tables": [
    {
      "table": "Users",
      "target": ["name", "address.street"]
    }
  ]
})
```

```go
searchClient, _ := xata.NewSearchAndFilterClient()
results, _ := searchClient.SearchTable(context.TODO(), xata.SearchTableRequest{
  Payload: xata.SearchTableRequestPayload{
    Query:  *xata.String("new st"),
    Target: []*xata.TargetExpressionItem{
      xata.NewTargetExpression("name"),
      xata.NewTargetExpression("address.street"),
    },
  },
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "new st",
  "tables": [
    {
      "table": "Users",
      "target": ["name", "address.street"]
    }
  ]
}
```

</TabbedCode>

## Pagination

The search API provides a configurable page size and offset-based pagination. To skip pages set the offset to a multiple of the page size. For example, here we retrieve the second page of up to `10` search results:

<TabbedCode tabs={['TypeScript', 'Python', 'JSON']}>

```ts
const results = await xata.search.all('new st', {
  tables: [
    {
      table: 'Users',
      target: ['name', 'address.street']
    }
  ],
  page: {
    size: 10,
    offset: 10
  }
});
```

```python
results = xata.data().search_branch({
  "query": "new st",
  "tables": [
    {
      "table": "Users",
      "target": ["name", "address.street"]
    }
  ],
  "page": {
    "size": 10,
    "offset": 10
  }
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "new st",
  "tables": [
    {
      "table": "Users",
      "target": ["name", "address.street"]
    }
  ],
  "page": {
    "size": 10,
    "offset": 10
  }
}
```

</TabbedCode>

## Relevancy control

When using the search API, Xata assigns a relevancy score to each result and the results are returned sorted by their relevancy to the provided query. Behind the scenes,
Xata uses a [BM25](https://en.wikipedia.org/wiki/Okapi_BM25) algorithm to rank the results. The algorithm takes into account the frequency of the search terms in the document, the length of the document, and the frequency of the search terms in the database.

The relevancy score is returned for each result in the metadata. See [Searching across tables](#searching-across-tables) for sample responses.

You can fine-tune the relevancy of your searches by using column weights and boosters. We recommend using the web UI to experiment with these settings, then use the "Get Code Snippet" button to get the code to use in your app.

### Column weights

You can assign an integer weight to each column. The default weight is 1. The higher the weight, the higher the relevancy score will be for matches in that column.

<TabbedCode tabs={['TypeScript', 'Python', 'JSON']}>

```ts
const results = await xata.search.all('matrix', {
  tables: [
    {
      table: 'Posts',
      target: [{ column: 'title', weight: 5 }, { column: 'labels', weight: 2 }, '*']
    }
  ]
});
```

```python
results = xata.data().search_branch({
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "target": [
        {
          "column": "title",
          "weight": 5
        },
        {
          "column": "labels",
          "weight": 2
        },
        "*"
      ]
    }
  ]
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "target": [
        {
          "column": "title",
          "weight": 5
        },
        {
          "column": "labels",
          "weight": 2
        },
        "*"
      ]
    }
  ]
}
```

</TabbedCode>

In the above example, all columns are still targeted (`*` is included in `target`) but the `titles` and `labels` columns are boosted.

### Numeric Booster

The numeric booster allows making use of numeric columns to influence the relevancy score. This is particularly useful when you have columns that contain metrics relevant to the score, like "number of stars", or "number of views'.

<TabbedCode tabs={['TypeScript', 'Python', 'JSON']}>

```ts
const results = await xata.search.all('matrix', {
  tables: [
    {
      table: 'Posts',
      boosters: [{ numericBooster: { column: 'views', factor: 3 } }]
    }
  ]
});
```

```python
results = xata.data().search_branch({
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "boosters": [
        {
          "numericBooster": {
            "column": "views",
            "factor": 3
          }
        }
      ]
    }
  ]
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "boosters": [
        {
          "numericBooster": {
            "column": "views",
            "factor": 3
          }
        }
      ]
    }
  ]
}
```

</TabbedCode>

In this example, the `views` column is multiplied with the factor of 3 and then added to the relevancy score.

Additionally, the numeric booster can be configured with the `modifier` parameter which applies on the factor and value of the column before adding it to the item score.

The formula for the application of the modifier in combination with the factor is: `modifier(factor*value)+base_score`

The modifier parameter options are:

- `none`: default
- `log`: common logarithm (base 10).
- `log1p`: add 1 then take the common logarithm. This ensures that the output is positive if the value is between 0 and 1.
- `ln`: natural logarithm (base e).
- `ln1p`: add 1 then take the natural logarithm. This ensures that the output is positive if the value is between 0 and 1.
- `square`: raise the value to the power of two.
- `sqrt`: take the square root of the value.
- `reciprocal`: reciprocate the value (if the value is `x`, the reciprocal is `1/x`).

<TabbedCode tabs={['TypeScript', 'Python', 'JSON']}>

```ts
const results = await xata.search.all('matrix', {
  tables: [
    {
      table: 'Posts',
      boosters: [{ numericBooster: { column: 'views', factor: 3, modifier: 'square' } }]
    }
  ]
});
```

```python
results = xata.data().search_branch({
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "boosters": [
        {
          "numericBooster": {
            "column": "views",
            "factor": 3,
            "modifier": "square"
          }
        }
      ]
    }
  ]
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "boosters": [
        {
          "numericBooster": {
            "column": "views",
            "factor": 3,
            "modifier": "square"
          }
        }
      ]
    }
  ]
}
```

</TabbedCode>

In this example, the `views` column is multiplied with the factor of 3, then the result is squared and finally added to the relevancy score.

### Exact value booster

The exact value booster allows boosting the relevancy of records that have an exact value in a column. This can be useful to boost, for example, articles in a given category. A common scenario is to use exact value boosts to "pin" a particular result at the top of the results.

<TabbedCode tabs={['TypeScript', 'Python', 'JSON']}>

```ts
const results = await xata.search.all('matrix', {
  tables: [
    {
      table: 'Posts',
      boosters: [{ valueBooster: { column: 'labels', value: 'movies', factor: 5 } }]
    }
  ]
});
```

```python
results = xata.data().search_branch({
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "boosters": [
        {
          "valueBooster": {
            "column": "labels",
            "value": "movies",
            "factor": 5
          }
        }
      ]
    }
  ]
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "boosters": [
        {
          "valueBooster": {
            "column": "labels",
            "value": "movies",
            "factor": 5
          }
        }
      ]
    }
  ]
}
```

</TabbedCode>

In the above example, records that have the label "movies" in the `labels` column will receive a boost factor of 5 added to their relevancy score.

### Date booster

The date booster allows boosting the relevancy of records that have a date in a column depending on the proximity of the matching date to a provided date. This can be used to boost, for example, more recent articles. In the below example we'll use Xata's internal `xata.createdAt` object that is available on all records.

<TabbedCode tabs={['TypeScript', 'Python', 'JSON']}>

```ts
const results = await xata.search.all('matrix', {
  tables: [
    {
      table: 'Posts',
      boosters: [
        {
          dateBooster: {
            column: 'xata.createdAt',
            decay: 0.5,
            scale: '30d',
            factor: 10
          }
        }
      ]
    }
  ]
});
```

```python
results = xata.data().search_branch({
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "boosters": [
        {
          "dateBooster": {
            "column": "xata.createdAt",
            "decay": 0.5,
            "scale": "30d",
            "factor": 10
          }
        }
      ]
    }
  ]
})
```

```jsonc
// POST https://{workspace}.{region}.xata.sh/db/{db}:{branch}/search

{
  "query": "matrix",
  "tables": [
    {
      "table": "Posts",
      "boosters": [
        {
          "dateBooster": {
            "column": "xata.createdAt",
            "decay": 0.5,
            "scale": "30d",
            "factor": 10
          }
        }
      ]
    }
  ]
}
```

</TabbedCode>

The date booster is configured via `origin`, `scale`, and `decay` parameters. The further away from the `origin`,
the more the score decays. The decay function uses an exponential function. The exponential function returns a value between 0 and 1, which is added to the score. This value can be multiplied by the `factor` parameter in order to provide a bigger impact.

With the parameters applied from the previous example this will boost posts from 30 days ago by 50% of what
the equivalent post from today would score.

The parameter definitions are:

- `column`: the column in which to look for the value.
- `origin`: The datetime from where to apply the score decay function. If it is not specified, the current date and time is used.
- `scale`: The duration at which distance from origin the score is decayed with factor, using an exponential function. It is formatted as number + unit of time, for example: `5d`, `20m`, `10s`.
- `decay`: The decay factor to expect at "scale" distance from the "origin".
- `factor`: The factor to multiply the decayed boost with.
